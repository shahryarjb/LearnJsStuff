#test-driven development (TDD)

With Jest as your test framework, you’ll be able to create a light- ning-fast feedback loop

**Vitest is designed for compatibility with tests written for Jest**

Jest runs in a Node process

jest runs in node process because it’s possible to simulate most browser apis in node with use of jsdom library

Advantages:

- tests can be run much more quickly
- code coverage can be calculated easily,
- the same tests can be run on any system whether it’s a developer’s laptop or a continuous integration server with consistent results

project fizz-buzz

`describe()` declares a `*test suite`* ,which is a grouping of tests. Its first argument
is a name, and the second is a function containing one or more tests.

```jsx
const greeting = (guest) => `Hello, ${guest}!`;

describe('greeting()', () => {
  it('says hello', () => {
    expect(greeting('Jest')).toBe('Hello, Jest!');
  });
});

```

`it()` declares a *test*. Its first argument is a name, and the second is a
function with the actual test code.

`expect()` creates an *assertion*. It takes a single argument, typically a value
generated by the code being tested, and returns an object that provides
a set of matcher functions.

`toBe()` is a *matcher* that performs a strict equality test between the value being
tested (the expect() argument) and the expected value (its own argument).

run test with

```jsx
npm test
```

run test automatically

```jsx
npx jest --watchAll
```

measure test coverage

```jsx
npx jest --coverage
```

we should try adding a test to cover the case where it fails

تست برای این کد

```jsx
(num) => {
  if (num % 15 === 0) return 'FizzBuzz';
  return `${num}`;
};
```

test:

```jsx
const fizzBuzz = require('./index');
describe('fizzBuzz()', () => {
  it('returns "FizzBuzz" for multiples of 3 and 5', () => {
    expect(fizzBuzz(15)).toBe('FizzBuzz');
    expect(fizzBuzz(30)).toBe('FizzBuzz');
  });
});

```

کد کاوریج این میشه

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/28aaf9fb-7428-4beb-aec8-317950f18fb8/c7ab294f-22b7-45d7-9d29-1096c033628c/Untitled.png)

نشون میده 75 درصد کد کاورج و 50 درصد برنچ نتایج احتمال از if/else هاست

نشون میده که تست ها فقط `num % 15 === 0` رو کاور میکنن

تست هایی باید اضافه بشه که به fail بشه بتونیم مشکلات کد رو بفهمیم

```jsx
const fizzBuzz = require('../index');
describe('fizzBuzz()', () => {
  it('returns "FizzBuzz" for multiples of 3 and 5', () => {
    expect(fizzBuzz(15)).toBe('FizzBuzz');
    expect(fizzBuzz(30)).toBe('FizzBuzz');
  });
  it('returns the given number for multiples of neither 3 nor 5', () => {
    expect(fizzBuzz(1)).toBe('1');
    expect(fizzBuzz(22)).toBe('22');
  });
});

```

code coverage:

![Screenshot 2024-07-16 173508.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/28aaf9fb-7428-4beb-aec8-317950f18fb8/a938d532-36f1-4e70-bb3a-3eb0570411b1/Screenshot_2024-07-16_173508.png)

نشون میده در این تست همه مسیره ها و خروجی های مد نظر در کد کاور شده

```jsx
Like all metrics, code coverage is imperfect—projects with impressive code
coverage numbers don’t necessarily have the most useful tests—but the
numbers can still guide you in the right direction. It’s especially handy for
identifying parts of your project with large gaps in test coverage.
```

fizz buzz code and test

code and test:

```jsx
{
  if (num % 15 === 0) return 'FizzBuzz';
  if (num % 3 === 0) return 'Fizz';
  if (num % 5 === 0) return 'Buzz';
  return `${num}`;
}

describe('fizzBuzz()', () => {
  it('returns "FizzBuzz" for multiples of 3 and 5', () => {
    expect(fizzBuzz(15)).toBe('FizzBuzz');
    expect(fizzBuzz(30)).toBe('FizzBuzz');
  });
  it('returns "Fizz" for multiples of 3', () => {
    expect(fizzBuzz(3)).toBe('Fizz');
    expect(fizzBuzz(33)).toBe('Fizz');
  });
  it('returns "Buzz" for multiples of 5', () => {
    expect(fizzBuzz(5)).toBe('Buzz');
    expect(fizzBuzz(20)).toBe('Buzz');
  });
  it('returns the given number for multiples of neither 3 nor 5', () => {
    expect(fizzBuzz(1)).toBe('1');
    expect(fizzBuzz(22)).toBe('22');
  });
});
```

# integrated tools:

finds all palindromes in a string which spelled the same forwards and backwards

example:

```jsx
palindromes('What number is never odd or even, asked the Sphinx?')
// would return
['neveroddoreven']
```

test:

```jsx
const palindromes = require('./palindromes');
describe('palindromes()', () => {
  it('correctly identifies one-word palindromes', () => {
    expect(palindromes('madam')).toEqual(['madam']); //Note
  });
});

```

### Note:

`toBe()` does a strict equality check (like the === operator) which would fail here

The` toEqual()` assertion method, by contrast, checks for deep object equality. So the assertion `expect(x).toEqual(['madam'])` passes as long as x is an array with the string "madam" as its only entry.

so with this code all test should pass for the test

```jsx
module.exports = (str) => {
  return [str];
};
```

## Eslint

A linter is a program that uses a set of rules to detect code that, though
syntactically valid, is likely to contain mistakes. A classic example is using
`=` (assignment) instead of `== or === (equality)` in an if statement:

```jsx
if (savings = 0) {
// This "condition" would empty your bank account!
}
```

Linting JavaScript is especially valuable because of its relatively freewheeling
nature. If you mistype `window` as `wimdow`, your program won’t refuse to run; it
just won’t run the way you’d hoped. Of course, one way to avoid such fatfinger
bugs is to have extensive test coverage. But a linter can often identify
such problems sooner, and give you more helpful information for fixing them.

**Note: eslint has pluggable architecture.**

There are plugins for
React, Angular, and every other popular JavaScript framework, aimed at
warning developers against the most common gotchas. also `Jest` has a plugin too

### Configure Eslint:

یک کانفیگوریشن برای `eslint` باید درست کنیم و  با دستور زیر ران کنیم.

```jsx
npx eslint
```

اسم فایلش

```jsx
.eslintrc.js
```

محتوای داخلش

```jsx
/** @type {import('eslint').Linter.Config} */ //!NOTICE 1
module.exports = {
  extends: ['eslint:recommended'],
};

```

**!NOTICE 1:** this `JSDoc-style` comment lets VS Code know what kind of object you’re
writing by referencing a type definition from the `@types/eslint` package

Comments like this are a great way
of bringing some of the benefits of TypeScript into config files that can’t
be written in TypeScript.

**!NOTICE 2:**  `extends` allows an `ESLint` configuration to inherit properties from another
ESLint configuration. You can view the eslint:recommended configuration in
the ESLint source code.

این eslint میگه که از قوانین recommended برای کانفیگ  استفاده کن

در مثال palindromes.js این eslint  از پارس arrow funtion ممانعت میکنه

به صورت دیفالت eslint بر پایه ecmascript 5 هست و arrow funtion ها رد ecmascript 6 (ecmascript 2015)اضافه شدند

برای رفعش 

```jsx
/** @type {import('eslint').Linter.Config} */
module.exports = {
  extends: ['eslint:recommended'],
  env: {
    es2021: true,
  },
};
```

کانفیگ بالا میذارریم ولی باز هم ارور خواهیم داشت بعد از اجرای `npx eslint palindromes.js`

<aside>
💡 The `module` global isn’t part of any `ECMAScript` standard, and would indeed be undefined in many environments.
We expect it to be defined, however, because this code will run in a Node
environment. To let `ESLint` know that, add another env entry:

</aside>

برای رفع مشکل

```jsx
/** @type {import('eslint').Linter.Config} */
module.exports = {
  extends: ['eslint:recommended'],
  env: {
    node: true, //ADDED THIS LINE
    es2021: true,
  },
};
```

دوباره`npx eslint palindromes.js` اجرا میکنیم

وقتی linting انجام میدیم در کنسول اروری نداشته باشیم یعنی کد اوکی هست

اما 

```css
npx eslint palindromes.test.js
```

ارور میده چون `eslint` نمیدونه که `describe` و `it` و 

این مشکل eslint میشه با یه `env entry` دیگه حلش کرد 

اما پلاگین eslint داریم مشکلش حل میکنه

`npm install --save-dev eslint-plugin-jest@27.2.1`

نصب میکنیم بعدش تو کانفیگ `eslint` میایم تو entry مربوط به plugins قرار میدیم

و همینطور configuration مربوط به `eslint` رو میذاریم درextends

```css
module.exports = {
  plugins: ["jest"],
  extends: ["eslint:recommended", "plugin:jest/recommended"],
  env: {
    node: true,
    es2021: true,
  },
};
```

کانفیگ بالا روی همه فایل های js اعمال میشه
ما میخوایم فقط روی فایل های تست اعمال بشه پس به ابجکت زیر تغییرش میدیم

```css
module.exports = {
  extends: ["eslint:recommended"],
  env: {
    node: true,
    es2021: true,
  },
  overrides: [
    {
      files: ["*.test.js"],
      plugins: ["jest"],
      extends: ["plugin:jest/recommended"],
    },
  ],
};

```

این کانفیگ کمک میکنه وقتی فایل سیو شد مشکلات رو نشون بده

```css
"eslint.run": "onSave",
```

نصب prittier یک کد فرمتر هست

```css
npm install --save-dev prettier@2.8.4
```

اجراش

```css
npx prettier palindromes.test.js
```

ساخت فایل .prettierrc.js

نحوه جلوگیری از ایجاد کانفلیکت بین prittier و eslint

هر دو ابزاری برای فرمت فایل هستند

نصب

```css
npm install --save-dev eslint-config-prettier@8.7.0
```

و توی کانفیگ eslint

```css
  extends: ["eslint:recommended", "prettier"],
```

به extends اضافه میکنیم

میتونیم به package.json اصافه کنیم

```css
"scripts": {
  "test": "jest",
  "lint": "eslint . && prettier --list-different .", //1
  "format": "eslint --fix . && prettier --log-level warn --write ." //2
},
```

1. The --list-different flag tells Prettier to list the names of any files with formatting
issues, rather than emitting their formatted contents. This matches
the behavior of ESLint with no flag.
2. The --loglevel warn flag tells Prettier not to emit any output unless it hits a
snag. This matches the behavior of ESLint with no flag.

# CH3:

- Jamstack frameworks like Next.tsx, Gatsby, and Remix that are designed
for building high-performance production websites. These frameworks
add some complexity in order to enable optimizations like server-side
rendering.
- Static build tools like Vite and Webpack that compile and bundle JavaScript
code but don’t provide a server. These simpler tools are great for building
React component libraries.

create new project with vite

```css
npm create vite@4.2.0 test-driven-carousel -- --template react-ts

cd test-driven-carousel
npm install
npm run dev
```

<aside>
💡 **Hot Module Reloading (HMR) that**
allows the Vite dev server to deliver code changes to the browser without a
full refresh

</aside>

JSX allows HTML-like markup to be embedded within JavaScript code. When
the code is compiled to pure JavaScript that a web browser can understand

each JSX tag is converted to a function call that tells React what kind of element
to create. So for instance, the code

```css
const helloJSX = <h1 className="super-big">Hello, JSX!</h1>;

```

would compile to something like:

```css
const helloJSX = React.createElement(
	'h1',
	{ className: 'super-big' },
	'Hello, JSX!'
);
```

ساخت .eslintrc.cjs

توجه که cjs هست چون common js هستش

```jsx
/** @type {import('eslint').Linter.Config} */
module.exports = {
  extends: ['eslint:recommended', 'prettier'],
  env: {
    node: true,
    es2021: true,
  },
  overrides: [{ files: ['*.cjs'] }], //1
};

```

1. By default, ESLint only lints files with the .js extension. To make it cover
.cjs files, there are two options: Either specify --ext .cjs every time we call
the ESLint command, or add an overrides entry to the config for *.cjs files.
The overrides entry entry may look a little strange since it isn’t actually
overriding anything, but it’s less effort than the alternative.

این رو هم اضافه میکنیم به scripts پکیج جیسان

```json
"lint": "eslint . && prettier --list-different .",
"format": "eslint --fix . && prettier --loglevel warn --write .",
```

دو تا فایل `.eslintignore` و `.prettierignore` میسازیم

درش فولدر dist قرار میدیم تا build output های ما رو فرمت نکنن

اجرای لینت و فرمت

```bash
npm run lint
npm run format
```

حالا `eslint` روی فایل های ts نیاز داره از پلاگین استفاده کنه

نصب میکنیم

```bash
npm install --save-dev @typescript-eslint/parser @typescript-eslint/eslint-plugin
```

بعد هم نیاز هست به کانفیگ eslint اضافه بشه به بخش override

```jsx
/** @type {import('eslint').Linter.Config} */
module.exports = {
  extends: ["eslint:recommended", "prettier"],
  env: {
    node: true,
    es2021: true,
  },
  overrides: [
    { files: ["*.cjs"] },
    {
      files: ["*.ts", "*.tsx"],
      extends: [
        "plugin:@typescript-eslint/recommended", //1
        "plugin:@typescript-eslint/recommended-requiring-type-checking", //2
      ],
      plugins: ["@typescript-eslint"],
      parser: "@typescript-eslint/parser",
      parserOptions: {
        project: true,
        tsconfigRootDir: __dirname,
      },
    },
  ],
};

```

1. The plugin:@typescript-eslint/recommended config is pretty minimalist. It exists
mainly to disable rules from the eslint:recommended config that are redundant
with TypeScript.
2.  The plugin:@typescript-eslint/recommended-requiring-type-checking config is more
interesting. To quote the typescript-eslint docs, this config enables rules
that “utilize the awesome power of TypeScript’s type checking APIs to
provide much deeper insights into your code.” One useful rule in this set
is the no-floating-promises rule, which requires you to handle promises
returned by async functions you call (e.g. by using the await keyword).
Treating async functions as if they were synchronous is a common
developer mistake, but thanks to the combined power of TypeScript and
ESLint, you don’t have to worry about it!

چون پروژه ری اکت هست بهتره که پلاگین ری اکت هم نصب بشه

```bash
npm install --save-dev eslint-plugin-react@7.32.2
```

پلاگین به `.eslintrc.cjs` اضافه میشه و همچنین محیط ری اکت هم اضافه میشه در `settings`

```jsx
/** @type {import('eslint').Linter.Config} */
module.exports = {
  extends: ["eslint:recommended", "prettier"],
  env: {
    node: true,
    es2021: true,
  },
  overrides: [
    { files: ["*.cjs"] },
    {
      files: ["*.ts", "*.tsx"],
      extends: [
        "plugin:@typescript-eslint/recommended",
        "plugin:@typescript-eslint/recommended-requiring-type-checking",
        "plugin:react/recommended",
        "plugin:react/jsx-runtime",
      ],
      settings: {
        react: {
          version: "detect",
        },
      },
      plugins: ["@typescript-eslint"],
      parser: "@typescript-eslint/parser",
      parserOptions: {
        project: true,
        tsconfigRootDir: __dirname,
      },
    },
  ],
};

```

اجرای لینت

```jsx
npm run lint
```

نصب vitest

```jsx
npm install --save-dev vitest@0.34.1
```

ضافه کردن به `package.json`

```jsx
"scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "test": "vitest",
    "preview": "vite preview",
    "lint": "eslint . && prettier --list-different .",
    "format": "eslint --fix . && prettier --loglevel warn --write ."
  },
```

خب

`Vitest` requires you to import basic functions like describe and expect

برای اینکه گلوبال دسترسی داشته باشیم

ابتدا `vite.config.ts`  رو اپدیت میکنیم که `defineConfig` داخلش import میکنیم

و `test.globals` رو `enabled` میکنیم

```jsx
import { defineConfig } from "vitest/config";
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
  },
});

```

در این فایل ممکنه اروری داشته باشیم که در قایل`tsconfig.json` به صورت زیر تغییر بدیم

```jsx
  "include": ["src" ,"vite.config.ts"],
```

درست میشه

بعد به `tsconfig.json` یه entry به نام *types*اضافه میکنیم

```jsx
"types": ["vitest/globals"],
```

با 

```jsx
npm run test
```

هم تست اجرا میشه

react testing library follow DOM-oriented testing philosophy

# React Testing Library

```jsx
npm install --save-dev @testing-library/react@14.0.0 happy-dom@9.20.3 @testing-library/jest-dom@6.0.0
```

happy-dom and jest-dome related to the DOM

happy-dom library is a JavaScript implementation of the DOM.  React expects to interact with the DOM, so a simulated DOM is a prerequisite for running React code.

JSDOM is more popular but; happy-dom is a newer, more performant alternative
that’s well-supported by Vitest.

The jest-dom extension for testing-library allows you to make assertions
about the state of the DOM in our tests, as you’ll soon see.

بعد نصب پکیج ها فایل vite.config.ts رو تغییر میدیم

```jsx
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  test: {
    globals: true,
    environment: "happy-dom",
    setupFiles: ["test-setup.ts"],
  },
});

```

The test-setup.ts file referenced from the config will install the matchers for DOM
assertions, saving you the trouble of having to import them in every test:

plugin for React Testing Library with rules designed to guard against common mistakes.

```bash
npm install --save-dev eslint-plugin-testing-library@6.0.1
```

و در کانفیگ eslint این اضافه میشه

```bash
plugin:testing-library/react
```

یک کامپوننت button داریم

```bash
const CarouselButton = () => <button />;
export default CarouselButton;
```

و تستش

```bash
import { render, screen } from '@testing-library/react';
import CarouselButton from './CarouselButton';
describe('CarouselButton', () => {
  it('renders a <button>', () => {
    render(<CarouselButton />);
    expect(screen.getByRole('button')).toBeInTheDocument();
  });
});

```

فانکشن `render` مشخص هست یک المنت ری اکت رو میگیره و رندر میکنه به DOM

The screen.getByRole function is built into Testing Library. It finds a single
element in the DOM with the given ARIA role; it’ll throw an error if no
elements match, or if more than one element matches. The toBeInTheDocument
matcher comes from @testing-library/jest-dom. Given the behavior of getByRole,
the matcher is redundant, but it makes the test more readable.

### working with props

کامپوننت دکمه

```bash
import { ReactNode } from "react";

const CarouselButton = ({ children }: { children?: ReactNode }) => (
  <button>{children}</button>
);
export default CarouselButton;

```

تست

```jsx
import { render, screen } from '@testing-library/react';
import CarouselButton from './CarouselButton';

describe('CarouselButton', () => {
  it('passes `children` through to the <button>', () => {
    const text = 'Button text';
    render(<CarouselButton>{text}</CarouselButton>);
    expect(screen.getByRole('button')).toHaveTextContent('Button text');
  });
});

```

وقتی یک کامپوننت به‌صورت یک تابع تعریف می‌شود، آن تابع به‌عنوان اولین آرگومان،  props کامپوننت را دریافت می‌کند. لیست آرگومان ({ children }) از سینتکس destructuring ابجکت استفاده می‌کند تا props.children را به‌عنوان children استخراج کند، که سپس به کامپوننت <button> رندر شده، منتقل می‌شود.

دستور زیر
گزینه noEmit به TypeScript می‌گوید که ما فقط می‌خواهیم بررسی نوع‌ها را انجام دهیم و نمی‌خواهیم کامپایلر هیچ کدی را به کد ترنسپایل شده خروجی دهد.

```jsx
npx tsc --noEmit
```

ما می‌خواهیم از پاس دادن یک هندلر رویداد onClick پشتیبانی کنیم. همچنین می‌خواهیم از پاس دادن prop مربوط به className برای استایل‌دهی پشتیبانی کنیم. همچنین می‌خواهیم از ویژگی‌های data- نیز پشتیبانی کنیم. به این فکر کنید که اگر ما فقط هر prop که توسط عنصر <button> پشتیبانی می‌شود را به صورت پیش‌فرض پاس دهیم، چه اتفاقی می‌افتد؟

این در واقع یک عمل بسیار رایج در React است و منطقی نیز به نظر می‌رسد. برای این کار، یک تست دیگر به بلوک describe() موجود اضافه کنید و اطمینان حاصل کنید که props بیشتری بررسی شوند:

```jsx
import { render, screen } from "@testing-library/react";
import CarouselButton from "./CarouselButton";

describe("CarouselButton", () => {
  it("passes other props through to the <button>", () => {
    const className = "my-carousel-button";
    const dataAction = "prev";
    render(
      <CarouselButton className={className} data-action={dataAction}>
        Button text
      </CarouselButton>
    );
    expect(screen.getByRole("button")).toHaveClass(className);
    expect(screen.getByRole("button")).toHaveAttribute(
      "data-action",
      dataAction
    );
  });
});

```

تست به کد بالات غییر مکینه

خب props- داده‌ای همیشه با خط تیره هستند (همانطور که props- aria نیز که بعداً با آنها آشنا خواهیم شد، اینطور هستند). props- داده‌ای در DOM هیچ معنایی ندارند؛ آنها راهی برای اتصال جفت‌های کلید و مقدار دلخواه به عناصر هستند.

کامپوننت به کد زیر تغییر میکنه

```jsx
import { ComponentPropsWithRef } from "react";
const CarouselButton = (props: ComponentPropsWithRef<"button">) => (
  <button {...props} />
);
export default CarouselButton;
```

{...props} is the JSX spread operator. It’s equivalent to passing each prop
in the props object through individually. That includes children, since the
tag itself has no children.

# Testing Nested Markup

فایل  `CarouselSlide.tsx`

```jsx
const CarouselSlide = () => <figure />;
export default CarouselSlide;
```

در `CarouselSlide.test.tsx`

```jsx
import { render, screen } from "@testing-library/react";
import CarouselSlide from "./CarouselSlide";

describe("CarouselSlide", () => {
  it("renders a <figure>", () => {
    render(<CarouselSlide />);
    expect(screen.getByRole("figure")).toBeInTheDocument();
  });
});

```

تگ figure دو تا فرزند داره `<img>` `<figcaption>` 

و Testing Library تشویق می‌کند که تا حد امکان از نقش‌های ARIA استفاده کنید؛ به این ترتیب، تست‌ها با بهترین روش‌ها برای نوشتن مارکاپ قابل دسترس هماهنگ می‌شوند.

The <img> tag has an
associated ARIA role: "img". The <figcaption> tag, on the other hand, does not.
So we’ll use the data-testid attribute again to make it easy to select

تست به صورت زیر میشه

```jsx
import { render, screen } from "@testing-library/react";
import CarouselSlide from "./CarouselSlide";

describe("CarouselSlide", () => {
  it("renders an <img> and a <figcaption>", () => {
    render(<CarouselSlide />);
    const figure = screen.getByRole("figure");
    const img = screen.getByRole("img");
    const figcaption = screen.getByTestId("caption");
    expect(figure).toContainElement(img);
    expect(figure).toContainElement(figcaption);
  });
});

```

کامپوننت به صورت 

```jsx
const CarouselSlide = () => (
  <figure>
    <img />
    <figcaption data-testid="caption" />
  </figure>
);
export default CarouselSlide;

```

و یک سری پراپس دیگه داریم

1. imgUrl, a URL for the image displayed in the slide
2. description, a short piece of caption text
3. attribution, the name of image’s author
The imgUrl will be used as the src for the <img> tag. Add a test:

کامپوننت

```jsx
import { ReactNode } from "react";
const CarouselSlide = ({
  imgUrl,
  description,
  attribution,
}: {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
}) => (
  <figure>
    <img src={imgUrl} />
    <figcaption data-testid="caption">
      <strong>{description}</strong> {attribution}
    </figcaption>
  </figure>
);
export default CarouselSlide;

```

تست

```jsx
import { render, screen } from "@testing-library/react";
import CarouselSlide from "./CarouselSlide";

describe("CarouselSlide", () => {
  it("uses `description` and `attribution` as the caption", () => {
    const props = {
      description: "A jaw-droppingly spectacular image",
      attribution: "Trevor Burnham",
    };
    render(<CarouselSlide {...props} />);
    const figcaption = screen.getByTestId("caption");
    expect(figcaption).toHaveTextContent(
      `${props.description} ${props.attribution}`
    );
  });
});

```

هنوز یک ویژگی از کامپوننت ما کم است: برای پشتیبانی از استایل‌دهی، باید props‌های className و style را به عنصر <figure> منتقل کنیم. در واقع، برای حداکثر انعطاف‌پذیری، باید اجازه دهیم که هندلرهای ایونت، ویژگی‌های data- و غیره نیز پاس داده شوند. به طور خلاصه: باید همه props‌ها به جز سه موردی که به صراحت استفاده می‌کنیم را به عنصر <figure> منتقل کنیم.

```jsx
import { render, screen } from "@testing-library/react";
import CarouselSlide from "./CarouselSlide";
describe("CarouselSlide", () => {
  it("renders a <figure>", () => {
    render(<CarouselSlide />);
    expect(screen.getByRole("figure")).toBeInTheDocument();
  });
  it("renders an <img> and a <figcaption>", () => {
    render(<CarouselSlide />);
    const figure = screen.getByRole("figure");
    const img = screen.getByRole("img");
    const figcaption = screen.getByTestId("caption");
    expect(figure).toContainElement(img);
    expect(figure).toContainElement(figcaption);
  });
  it("passes `imgUrl` through to the <img>", () => {
    const imgUrl = "https://example.com/image.png";
    render(<CarouselSlide imgUrl={imgUrl} />);
    expect(screen.getByRole("img")).toHaveAttribute("src", imgUrl);
  });
  it("uses `description` and `attribution` as the caption", () => {
    const props = {
      description: "A jaw-droppingly spectacular image",
      attribution: "Trevor Burnham",
    };
    render(<CarouselSlide {...props} />);
    const figcaption = screen.getByTestId("caption");
    expect(figcaption).toHaveTextContent(
      `${props.description} ${props.attribution}`
    );
  });
  it("passes other props through to the <figure>", () => {
    const props = {
      className: "my-carousel-slide",
      "data-test-name": "My slide",
    };
    render(<CarouselSlide {...props} />);
    const figure = screen.getByRole("figure");
    expect(figure).toHaveClass(props.className);
    expect(figure).toHaveAttribute("data-test-name", props["data-test-name"]);
  });
});

```

کامپوننت

```jsx
import { ComponentPropsWithRef, ReactNode } from 'react';
const CarouselSlide = ({
  imgUrl,
  description,
  attribution,
  ...rest
}: {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
} & ComponentPropsWithRef<'figure'>) => (
  <figure {...rest}>
    <img src={imgUrl} />
    <figcaption data-testid="caption">
      <strong>{description}</strong> {attribution}
    </figcaption>
  </figure>
);
export default CarouselSlide;

```

مثل قبل، تابع تنها یک آرگومان می‌گیرد که به متغیرهای جداگانه تبدیل می‌شود. اما حالا یک آبجکت به نام rest داریم که تمام مقادیر باقی‌مانده از آبجکت props را که به‌طور صریح استخراج نشده‌اند، جمع‌آوری می‌کند. از طرف دیگر، گسترش JSX {...rest} جفت‌های کلید-مقدار را از آبجکت rest می‌گیرد و آنها را به props تبدیل می‌کند. از آنجا که rest در اصل از props‌های باقی‌مانده‌ای که به CarouselSlide داده شده بودند، ایجاد شده است، نتیجه این است که این props‌ها، یعنی همه به جز imgUrl، description و attribution، به عنصر <figure> منتقل می‌شوند.

شاید با سینتکس rest/spread در لیست آرگومان‌ها و آرایه‌ها آشنا باشید، که از ES6 پشتیبانی می‌شود. سینتکس rest/spread برای آبجکت‌ها جدیدتر است و به عنوان بخشی از مشخصات ES2018 به زبان اضافه شده است.

## Testing Stateful Components

ویژگی data-testid یک روش رایج در React Testing Library است که باعث می‌شود یک عنصر خاص به راحتی در تست انتخاب شود. برای استفاده از آن، مقدار این ویژگی را به سلکتور getByTestId() پاس دهید:

ویژگی data-testid را به عنصر مورد نظر اضافه کنید تا به راحتی قابل انتخاب در تست باشد. سپس، مقدار این ویژگی را به تابع getByTestId() در تست پاس دهید تا عنصر مورد نظر را پیدا کنید.

کد

```jsx
const Carousel = () => {
	return <div data-testid="carousel" />;
};
export default Carousel;
```

تست

```jsx
import { render, screen } from "@testing-library/react";
import Carousel from "./Carousel";
describe("Carousel", () => {
	it("renders a <div>", () => {
		render(<Carousel />);
		expect(screen.getByTestId("carousel")).toBeInTheDocument();
	});
});
```

کامپوننت لیستی از اسلاید ها دریافت میکنه

```jsx
import { ReactNode } from "react";
import CarouselSlide from "./CarouselSlide";
type Slide = {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
};
const Carousel = ({ slides }: { slides?: Slide[] }) => {
  return (
    <div data-testid="carousel">
      <CarouselSlide {...slides?.[0]} />
    </div>
  );
};
export default Carousel;

```

و تست 

```jsx
import { render, screen } from "@testing-library/react";
import Carousel from "./Carousel";

describe("Carousel", () => {
  const slides = [
    {
      imgUrl: "https://example.com/slide1.png",
      description: "Slide 1",
      attribution: "Uno Pizzeria",
    },
    {
      imgUrl: "https://example.com/slide2.png",
      description: "Slide 2",
      attribution: "Dos Equis",
    },
    {
      imgUrl: "https://example.com/slide3.png",
      description: "Slide 3",
      attribution: "Three Amigos",
    },
  ];
  it("renders the first slide by default", () => {
    render(<Carousel slides={slides} />);
    const img = screen.getByRole("img");
    expect(img).toHaveAttribute("src", slides[0].imgUrl);
  });
});

```

این اولین باری است که ما یک نوع را جدا از لیست آرگومان‌ها اعلام می‌کنیم و از کلمه کلیدی type استفاده می‌کنیم. این کار به ما اجازه می‌دهد تا به نوع توسط نام آن اشاره کنیم. در آینده ممکن است بخواهیم Carousel و CarouselSlide را بازسازی کنیم تا هر دو از این نوع استفاده کنند و اعلان‌های imgUrl، description و attribution را تکرار نکنیم.

سینتکس Slide[] نشان‌دهنده یک آرایه از آیتم‌هایی است که با نوع Slide مطابقت دارند. TypeScript همچنین از سینتکس معادل Array<Slide> پشتیبانی می‌کند.

 به یاد دارید که از عملگر گسترش prop استفاده کردیم؟ ما از سینتکس {...rest} استفاده کردیم تا هر جفت کلید-مقدار از آبجکت rest را به عنوان یک prop جداگانه منتقل کنیم. در اینجا ما همین کار را انجام می‌دهیم، اما با آبجکت slides[0]، و فقط در صورتی که وجود داشته باشد: سینتکس slides?.[0] مقدار undefined را برمی‌گرداند اگر خود slides تعریف نشده باشد، و گسترش undefined هیچ اثری ندارد.

نیاز مندی های بعدی

کاروسل با استفاده از یک عدد به نام slideIndex، اسلاید فعلی را ردیابی می‌کند.

- slideIndex ابتدا 0 است، به این معنی که اولین اسلاید نمایش داده می‌شود.
- با کلیک روی دکمه "Prev"، slideIndex کاهش می‌یابد و وقتی به کمتر از 0 می‌رسد، به آخرین اسلاید می‌رود.
- با کلیک روی دکمه "Next"، slideIndex افزایش می‌یابد و وقتی به بیشتر از آخرین اسلاید می‌رسد، به اولین اسلاید برمی‌گردد.
- کاروسل یک آرایه به نام slides می‌گیرد و اسلایدی را که توسط slideIndex مشخص شده، نمایش می‌دهد.

### Testing Interactions

برخلاف Enzyme، React Testing Library (RTL) اجازه نمی‌دهد که به وضعیت داخلی (state) مستقیماً دسترسی پیدا کنیم. اجزای داخلی کامپوننت به عنوان یک جعبه سیاه در نظر گرفته می‌شوند. بنابراین روش استاندارد ما برای تست وضعیت یک کامپوننت به این صورت خواهد بود:

1. کامپوننت را رندر کنیم.
2. و interactionکاربر را شبیه‌سازی کنیم.
3. بررسی کنیم که خروجی DOM کامپوننت مطابق انتظار ما تغییر کند.

برای شبیه‌سازی interaction کاربر، به یک وابستگی اضافی نیاز خواهیم داشت.

نصب

```jsx
npm install --save-dev @testing-library/user-event@14.4.3
```

دوتا intraction داریم کلیک روی دکمه prev و next

```jsx
import userEvent from "@testing-library/user-event";
...
it('advances the slide when the Next button is clicked', async () => { //1
  render(<Carousel slides={slides} />);
  const img = screen.getByRole('img');
  const nextButton = screen.getByTestId('next-button');
  const user = userEvent.setup();

  await user.click(nextButton); //2
  expect(img).toHaveAttribute('src', slides[1].imgUrl);
  await user.click(nextButton);
  expect(img).toHaveAttribute('src', slides[2].imgUrl);
  await user.click(nextButton);
  expect(img).toHaveAttribute('src', slides[0].imgUrl);
});

```

دقت کنید که این تست به عنوان یک تابع async معرفی شده است تا بتواند از کلمه کلیدی await برای انجام عملیات‌های غیرهمزمان استفاده کند.

رویدادهای شبیه‌سازی شده کاربر در Testing Library همیشه توابع async هستند. این کار اجازه می‌دهد تا رویداد به طور کامل حل شود و DOM قبل از ادامه تست به‌روزرسانی شود. یک اشتباه رایج که توسعه‌دهندگان مرتکب می‌شوند، عدم استفاده از await برای فراخوانی تابع async است؛ خوشبختانه، قانون no-floating-promises در `typescript-eslint` (که به عنوان بخشی از `@typescript-eslint/recommended-requiring-type-checking` فعال شده است) این مورد را تشخیص خواهد داد!

```jsx
import { ReactNode, useState } from "react";
import CarouselSlide from "./CarouselSlide";
import CarouselButton from "./CarouselButton";

type Slide = {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
};

const Carousel = ({ slides }: { slides?: Slide[] }) => {
  const [slideIndex, setSlideIndex] = useState(0); //1
  return (
    <div data-testid="carousel">
      <CarouselSlide {...slides?.[slideIndex]} />
      <CarouselButton
        data-testid="next-button"
        onClick={() => {
          if (!slides) return;
          setSlideIndex((i) => (i + 1) % slides.length); //2
        }}
      >
        Next
      </CarouselButton>
    </div>
  );
};
export default Carousel;

```

سینتکس useState(0) به این معناست که "از 0 به عنوان مقدار اولیه این state استفاده کن."

و Setterهای state مانند setSlideIndex می‌توانند یا یک مقدار خام یا یک تابع callback بپذیرند. تابع callback مقدار فعلی state را به عنوان آرگومان می‌گیرد و مقدار جدید را برمی‌گرداند. ما از callback استفاده می‌کنیم به جای setSlideIndex((slideIndex + 1) % slides.length) برای مقابله با یک مورد نادر: ممکن است کاربر قبل از اینکه Carousel دوباره رندر شود، دو بار روی دکمه کلیک کند، در این صورت هندلر onClick برای کلیک دوم همان مقدار slideIndex را می‌بیند که برای کلیک اول دیده بود، که این باعث می‌شود setter مستقیم هیچ اثری نداشته باشد.

و دکمه next

تست

```jsx
import { render, screen } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import Carousel from "./Carousel";

describe("Carousel", () => {
  const slides = [
    {
      imgUrl: "https://example.com/slide1.png",
      description: "Slide 1",
      attribution: "Uno Pizzeria",
    },
    {
      imgUrl: "https://example.com/slide2.png",
      description: "Slide 2",
      attribution: "Dos Equis",
    },
    {
      imgUrl: "https://example.com/slide3.png",
      description: "Slide 3",
      attribution: "Three Amigos",
    },
  ];
  it("renders a <div>", () => {
    render(<Carousel />);
    expect(screen.getByTestId("carousel")).toBeInTheDocument();
  });
  it("renders the first slide by default", () => {
    render(<Carousel slides={slides} />);
    const img = screen.getByRole("img");
    expect(img).toHaveAttribute("src", slides[0].imgUrl);
  });
  it("reverses the slide when the Prev button is clicked", async () => {
    render(<Carousel slides={slides} />);
    const img = screen.getByRole("img");
    const prevButton = screen.getByTestId("prev-button");
    const user = userEvent.setup();

    await user.click(prevButton);
    expect(img).toHaveAttribute("src", slides[2].imgUrl);
    await user.click(prevButton);
    expect(img).toHaveAttribute("src", slides[1].imgUrl);
    await user.click(prevButton);
    expect(img).toHaveAttribute("src", slides[0].imgUrl);
  });
  it("advances the slide when the Next button is clicked", async () => {
    render(<Carousel slides={slides} />);
    const img = screen.getByRole("img");
    const nextButton = screen.getByTestId("next-button");
    const user = userEvent.setup();
    await user.click(nextButton);
    expect(img).toHaveAttribute("src", slides[1].imgUrl);
    await user.click(nextButton);
    expect(img).toHaveAttribute("src", slides[2].imgUrl);
    await user.click(nextButton);
    expect(img).toHaveAttribute("src", slides[0].imgUrl);
  });
});

```

کد

```jsx
import { ReactNode, useState } from 'react';
import CarouselButton from './CarouselButton';
import CarouselSlide from './CarouselSlide';
type Slide = {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
};
const Carousel = ({ slides }: { slides?: Slide[] }) => {
  const [slideIndex, setSlideIndex] = useState(0);
  return (
    <div data-testid="carousel">
      <CarouselSlide {...slides?.[slideIndex]} />
      {}
      <CarouselButton
        data-testid="prev-button"
        onClick={() => {
          if (!slides) return;
          setSlideIndex((i) => (i + slides.length - 1) % slides.length);
        }}
      >
        Prev
      </CarouselButton>
      {}
      <CarouselButton
        data-testid="next-button"
        onClick={() => {
          if (!slides) return;
          setSlideIndex((i) => (i + 1) % slides.length);
        }}
      >
        Next
      </CarouselButton>
    </div>
  );
};
export default Carousel;

```

# Styled components

مهمترین مزیت استفاده

Styles can be subjected to unit tests.

نصب

```jsx
npm install --save styled-components@6.0.5
```

استایل دهی اسلاید

```jsx
import { ComponentPropsWithRef, ReactNode } from "react";
import styled from "styled-components";
const ScaledImg = styled.img`
  object-fit: cover;
  width: 100%;
  height: 500px;
`;
const CarouselSlide = ({
  imgUrl,
  description,
  attribution,
  ...rest
}: {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
} & ComponentPropsWithRef<"figure">) => (
  <figure {...rest}>
    <ScaledImg src={imgUrl} />
    <figcaption data-testid="caption">
      <strong>{description}</strong> {attribution}
    </figcaption>
  </figure>
);
export default CarouselSlide;

```

و styled.img یک تابع است که یک کامپوننت تولید می‌کند که یک تگ <img> را با استایل‌های داده شده رندر می‌کند. وقتی یک نمونه از آن کامپوننت ScaledImg نصب می‌شود، styled-components به صورت پویا یک قانون استایل با استایل‌هایی که شما فراهم کرده‌اید، با استفاده از یک selector نام کلاس مبتنی بر هش آن استایل‌ها، اضافه می‌کند.

اینجا یه کم بازی با سینتکس داریم که به کمک یک ویژگی از ES6 به نام tagged templates انجام می‌شه. اگه یه تابع رو مستقیم جلوی یه template string بذاری (همونایی که با backticks مشخص می‌شن)، اون تابع با template string به عنوان آرگومان فراخوانی می‌شه.

برای ScaledImg، می‌تونی از سینتکس معمولی فراخوانی تابع استفاده کنی، چون رشته‌ی استایل‌ها ثابته. اما قدرت tagged template زمانی به کار میاد که رشته دارای interpolations (سینتکس ${...}) باشه: هر تکه از رشته‌ی interpolated به عنوان آرگومان جداگانه به تابع پاس داده می‌شه. این به تابع تگ اجازه می‌ده که متغیرهای interpolated رو پردازش کنه. همونطور که به زودی می‌بینیم، styled-components از این قابلیت استفاده می‌کنه.

یک پراپس imgHeight در نظر میگیریم

```jsx
import { ComponentPropsWithRef, ReactNode } from "react";
import styled from "styled-components";
const DEFAULT_IMG_HEIGHT = "500px";

export type CarouselSlideProps = {
  imgUrl?: string;
  /** @default "500px" */
  imgHeight?: string | number;
  description?: ReactNode;
  attribution?: ReactNode;
} & ComponentPropsWithRef<"figure">;

type ImgComponentProps = {
  $height?: CarouselSlideProps["imgHeight"];
};
const ScaledImg = styled.img<ImgComponentProps>`
  object-fit: cover;
  width: 100%;
  height: ${(props) =>
    typeof props.$height === "number" ? `${props.$height}px` : props.$height};
`;
const CarouselSlide = ({
  imgUrl,
  imgHeight = DEFAULT_IMG_HEIGHT,
  description,
  attribution,
  ...rest
}: CarouselSlideProps) => (
  <figure {...rest}>
    {}
    <ScaledImg src={imgUrl} $height={imgHeight} />
    {}
    <figcaption data-testid="caption">
      <strong>{description}</strong> {attribution}
    </figcaption>
  </figure>
);
export default CarouselSlide;

```

سینتکس /** ... */ نشان‌دهنده یک کامنت JSDoc است. این کامنت‌ها بر رفتار کد یا چک‌کننده نوع (typechecker) تأثیری ندارند، اما می‌توانند اطلاعات مفیدی به توسعه‌دهندگانی که از کد شما استفاده می‌کنند، ارائه دهند و نوع‌های TypeScript را تکمیل کنند.

مثلاً، در VS Code اگر ماوس را روی imgHeight در <CarouselSlide imgHeight={}> ببرید، ویرایشگر هم نوع TypeScript آن و هم JSDoc مرتبط را نشان می‌دهد. اینجا، کامنت JSDoc نشان می‌دهد که مقدار پیش‌فرضی که استفاده می‌شود اگر prop imgHeight تنظیم نشده باشد، "500px" است.

نوع ImgComponentProps به عنوان یک پارامتر نوع برای تابع styled.img استفاده می‌شود. در این مورد، پارامتر نوع نشان می‌دهد که مجموعه‌ای از props‌ها که کامپوننت ScaledImg برگردانده شده توسط آن تابع قادر به پذیرش آنها خواهد بود، علاوه بر هر چیزی که تگ img بومی می‌تواند بپذیرد. پیشوند $ در $height یک قرارداد در styled-components است که نشان می‌دهد یک prop موقتی است که برای استایل‌های interpolated استفاده می‌شود، اما به تگ <img> در DOM منتقل نمی‌شود.

اینجا جاییه که styled-components واقعاً جذاب می‌شه: مقادیر interpolated در قالب استایل می‌تونن به تابعی از props‌های کامپوننت تبدیل بشن! در حالی که CSS معمولی ثابته، این استایل‌ها کاملاً دینامیک هستن. اگه prop imgHeight تغییر کنه، استایل‌ها به طور خودکار به‌روزرسانی می‌شن.

در حال حاضر، imgHeight می‌تونه به صورت اسلاید به اسلاید تغییر کنه، چون Carousel کل آبجکت داده‌های اسلاید رو به عنوان props به CarouselSlide منتقل می‌کنه. اما در بیشتر موارد، کاربری که از Carousel استفاده می‌کنه، می‌خواد که ارتفاع ثابت داشته باشه. بنابراین، بیایید یک prop به Carousel اضافه کنیم که می‌تونه مقدار پیش‌فرض imgHeight در CarouselSlide رو تغییر بده:

carousel:

```jsx
import { ReactNode, useState } from "react";
import CarouselButton from "./CarouselButton";
import CarouselSlide, { CarouselSlideProps } from "./CarouselSlide";
type Slide = {
  imgUrl?: string;
  description?: ReactNode;
  attribution?: ReactNode;
};

export type CarouselProps = {
  slides: Slide[];
  defaultImgHeight?: CarouselSlideProps["imgHeight"];
};

const Carousel = ({ slides, defaultImgHeight }: CarouselProps) => {
  const [slideIndex, setSlideIndex] = useState(0);
  return (
    <div data-testid="carousel">
      ❷ <CarouselSlide imgHeight={defaultImgHeight} {...slides?.[slideIndex]} />
      {}
      <CarouselButton
        data-testid="prev-button"
        onClick={() => {
          if (!slides) return;
          setSlideIndex((i) => (i + slides.length - 1) % slides.length);
        }}
      >
        Prev
      </CarouselButton>
      {}
      <CarouselButton
        data-testid="next-button"
        onClick={() => {
          if (!slides) return;
          setSlideIndex((i) => (i + 1) % slides.length);
        }}
      >
        Next
      </CarouselButton>
    </div>
  );
};
export default Carousel;

```

سینتکس CarouselSlideProps["imgHeight"] به نوع فیلد imgHeight در CarouselSlideProps اشاره می‌کند.

توجه داشته باشید که ترتیب اینجا مهم است: چون گسترش ...slides?.[slideIndex] بعد از اینکه imgHeight به defaultImgHeight تنظیم شده، می‌آید، مقدار imgHeight از اسلاید اولویت خواهد داشت (اگر تعریف شده باشد).

حالا سعی کنید defaultImgHeight را روی ExampleCarousel تنظیم کنید و باید ببینید که ارتفاع کاروسل در مرورگر تغییر می‌کند.

شاید این سوال پیش بیاید: styled-components چگونه این استایل‌ها را به تگ <img> اعمال کرده است؟ اگر یکی از تگ‌های <img> را در مرورگر بازرسی کنید، همان‌طور که در اسکرین‌شات بعدی نشان داده شده، خواهید دید که ویژگی کلاس آن پر از کدهای عجیب و غریب است. چیزی شبیه به class="sc-bdVaJa hhfYDU". کتابخانه styled-components این نام‌های کلاس را برای شما تولید کرده و یک قانون استایل مربوطه را به یک تگ <style> در <head> صفحه تزریق کرده است.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/28aaf9fb-7428-4beb-aec8-317950f18fb8/1750c4f0-8f00-4f25-9547-ee129118ce17/Untitled.png)

در واقع، عنصر <img> دارای دو نام کلاس است که توسط styled-components تولید شده‌اند. یکی از این کلاس‌ها که با پیشوند sc- شروع می‌شود، یک نام کلاس ثابت است که styled-components برای سلکتورها استفاده می‌کند. دیگری، که استایل‌ها به آن اعمال می‌شوند، از هش استایل‌ها تولید شده است. در عمل، این تفاوت فقط یک جزئیات پیاده‌سازی است. فقط به یاد داشته باشید: هرگز نباید هیچ یک از نام‌های کلاس تولید شده توسط styled-components را در کد خود کپی کنید! تمامی نام‌های کلاس تولید شده ممکن است تغییر کنند.

داشتن نام‌های کلاس ناخوانا یک نقطه ضعف ناخوشایند از styled-components است. خوشبختانه، با کمک یک پیش‌پردازنده محبوب به نام Babel، می‌توان این مشکل را کاهش داد.

### Better Debugging with the Babel Plugin

توانایی‌های قدرتمند تغییر زبان Babel می‌تواند برای تطبیق کد شما با نیازهای کتابخانه‌های خاص استفاده شود. این دقیقاً کاری است که پلاگین رسمی styled-components برای Babel انجام می‌دهد، با بهبود کد styled-components در زمان کامپایل برای عملکرد بهتر و اشکال‌زدایی آسان‌تر. این یک افزودنی توصیه‌شده برای هر پروژه‌ای است که از styled-components استفاده می‌کند.

نصب

```jsx
npm install --save-dev babel-plugin-styled-components@2.1.4
```

بعد به vite.config.ts اضافه میکنیمش

```jsx
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [
    react({
      babel: {
        plugins: [
          [
            "babel-plugin-styled-components",
            {
              displayName: true,
              fileName: true,
            },
          ],
        ],
      },
    }),
  ],
  test: {
    globals: true,
    environment: "happy-dom",
    setupFiles: ["test-setup.ts"],
  },
});

```

تفاوت را متوجه شدید؟ برای یک چیز، نام کلاس کوتاه تغییر کرده است. (دوباره تاکید می‌کنم: هرگز نام‌های کلاس تولید شده توسط styled-components را در کد خود کپی نکنید!) اما مهم‌تر از همه، نام کلاس که قبلاً با پیشوند sc- بود، اکنون با CarouselSlide__ScaledImg- شروع می‌شود. با تشکر از پلاگین Babel، اکنون می‌توانید نام ماژول (CarouselSlide) و نام کامپوننت (ScaledImg) را که با هر عنصری که توسط styled-components استایل داده شده، مشاهده کنید! با این حال، توجه داشته باشید که نام کلاس کوتاه همچنان همان است که به عنوان سلکتور استایل استفاده می‌شود.

پلاگین Babel همچنین بهبودهای کارایی را به همراه دارد، از جمله حذف کامنت‌ها و فضای خالی غیرضروری از داخل template literals شما، به شما اجازه می‌دهد استایل‌هایتان را به شکلی دوستانه برای انسان‌ها بنویسید بدون اینکه نگران تاثیر آن بر پهنای باند محدود کاربران باشید.

### Linting Styles with Stylelint

خوشبختانه، امکان استفاده از lint stylelint برای استایل‌هایی که برای styled-components نوشته شده‌اند، وجود دارد. از آنجا که ESLint محتوای آن template literals را نادیده می‌گیرد، این دو linter هیچ مشکلی برای همزیستی مسالمت‌آمیز ندارند.

برای این کار به چند بسته نیاز دارید: خود stylelint، stylelint-processor-styled-components برای اطلاع دادن به stylelint که کدام قسمت‌های فایل را بخواند، stylelint-config-standard برای فعال کردن یک مجموعه قوانین پیش‌فرض معقول، و postcss-styled-syntax برای اطلاع دادن به Stylelint که چگونه استایل‌ها را درون فایل‌های JavaScript/TypeScript تجزیه کند. این بسته‌ها را به عنوان وابستگی‌های توسعه نصب کنید:

نصب

```jsx
npm install --save-dev stylelint@15.10.2 stylelint-config-standard@34.0.0 postcss-styled-syntax@0.4.0
```

فایل .stylelintrc.cjs میسازیم

```jsx
module.exports = {
extends: ["stylelint-config-standard"],
customSyntax: "postcss-styled-syntax",
allowEmptyInput: true,
};
```

و .stylelintignore حاوی dist

و به package.json

```jsx
"lint:js": "eslint . && prettier --list-different .",
 "lint:css": "stylelint \"**/*.{ts,tsx}\"",
 "lint": "npm run lint:js && npm run lint:css",
 "format:js": "eslint --fix . && prettier --loglevel warn --write .",
 "format:css": "stylelint \"**/*.{ts,tsx}\" --fix",
 "format": "npm run format:js && npm run format:css",
```

و stylelint را به اسکریپت‌های lint و format پروژه اضافه کنید. چون می‌خواهیم به فایل‌های TypeScript (با پسوندهای .ts یا .tsx) نگاه کند، دستور مربوطه stylelint "**/*.{ts,tsx}" است. برای مدیریت طول خطوط در فایل package.json، اسکریپت را به دو قسمت تقسیم کنید. اسکریپت موجود را lint
بنامید و اسکریپت stylelint را lint

و دستور زیر ران میشه

```jsx
npm run lint
```

## make assertions about styles

نصب

```jsx
npm install --save-dev jest-styled-components@7.1.1
```

ایمپورت jest-styled-components داخل test-setup.ts

```jsx
 import "jest-styled-components";
```

حالا یک assertion جدید به نام `toHaveStyleRule()` در دسترس دارید. یک تست به بلوک `describe("CarouselSlide")` اضافه کنید تا مطمئن شوید که استایل‌های مورد انتظار `styled.img` به درستی اعمال می‌شوند.

هاسکی برای git hook

استوری بوک برای داکیومنت